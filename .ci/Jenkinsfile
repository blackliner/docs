#!groovyâ€‹

Map<String, String> versions = [
        'master': '1.31',
        'release/1.30.2': '1.30',
        'release/1.29.2': '1.29',
        'release/1.28.2': '1.28',
        'release/1.27.1': '1.27',
        'release/1.26.1': '1.26',
        'release/1.25.2': '1.25',
        'release/1.24.1': '1.24',
        'release/1.23.0': '1.23',
        'release/1.22.3': '1.22',
        'release/1.21.3': '1.21',
        'release/1.20.5': '1.20',
        'release/1.19.3': '1.19',
        'release/1.18.5': '1.18',
        'release/1.17.2': '1.17',
        'release/1.16.1': '1.16',
        'release/1.15.2': '1.15',
        'release/1.14.5': '1.14',
        'release/1.13.3': '1.13',
        'release/1.12.3': '1.12',
        'release/1.11.2': '1.11',
        'release/1.10.2': '1.10',
        'release/1.9.4': '1.9',
        'release/1.8.4': '1.8',
        'release/1.7.4': '1.7',
        'release/1.6.1': '1.6',
        //'release/1.5.2': '1.5',  // This one fails to generate
        'release/1.4.5': '1.4',
        'release/1.3.3': '1.3'
        ]

node('Linux') {
    echo "Building ${env.BRANCH_NAME}, change ${env.CHANGE_ID}"
    boolean isMaster = env.BRANCH_NAME == 'master'

    stage('Clone sources') {
        dir('src') {
            checkout scm
            writeJSON json: versions, file: 'versions.json'
        }
    }

    def image = null
    stage('Build docker image') {
        image = docker.build('conan-docs', '-f src/.ci/Dockerfile .')  // It should cache the image
    }

    stage('Test build') {
        parallel html: {
            image.inside {
                sh 'make -C src html'
            }
        },
        pdf: {
            image.inside {
                sh 'make -C src latex'
            }
        },
        spelling: {
            image.inside {
                sh 'make -C src spelling'
            }
        },
        linkcheck: {
            image.inside {
                int output = sh(script: 'make -C src linkcheck', returnStatus: true)
                if (output != 0 && isMaster) {
                    currentBuild.result = 'FAILURE'
                    error('Stop here, linkcheck in "master" failed!')
                }
            }
        }
    }

    if (!isMaster) {
        echo 'Stop here, do not run anything else for branches other than master'
        //return // TODO: Return here, remove comment
    }

    stage('Create worktrees') { // Do this sequentially
        dir('src') {
            versions.each { branchName, folderName ->
                sh "git fetch origin ${branchName}:${branchName}"
                sh "git worktree add ../${folderName} ${branchName}"
            }
            // Prepare the worktree for gh-pages too
            sh 'git fetch origin gh-pages:gh-pages'
            sh 'git worktree add ../gh-pages gh-pages'
        }
        sh 'rm -fr gh-pages/.git'
        sh 'rm -fr gh-pages/en'
    }

    Map parallelJobs = [:]
    versions.each { key, value ->
        String branchName = key
        String folderName = value
        parallelJobs[folderName] = {
            echo "Run parallel job for ${branchName} inside ${folderName}"
            image.inside {
                stage('Prepare sources') {
                    sh "cp src/versions.json ${folderName}/versions.json"
                    sh "cp -R src/_themes ${folderName}/_themes"
                }

                stage('HTML') {
                    sh "sphinx-build -W -b html -d ${folderName}/_build/.doctrees ${folderName}/ gh-pages/en/${folderName}"
                }

                stage('PDF') {
                    sh "sphinx-build -W -b latex -d ${folderName}/_build/.doctrees ${folderName}/ ${folderName}/_build/latex"
                    sh "make -C ${folderName}/_build/latex all-pdf"
                    sh "cp ${folderName}/_build/latex/conan.pdf gh-pages/en/${folderName}/conan.pdf"
                }
            }
        }
    }

    stage('Generate all releases') {
        parallelJobs.failFast = true
        parallel parallelJobs
    }

    stage('Prepare gh-branch') {
        dir('gh-pages') {
            sh 'ls -la'
            sh 'ls -la en'
            sh "cp -R en/${versions['master']} en/latest"
            // sh 'cp src/versions.json versions.json'
            sh 'cp en/latest/404.html 404.html'

            String content = readFile('404.html')
            String prefix = 'https://docs.conan.io/en/latest'
            content = content.replaceAll('href="_', "href=\"${prefix}/_")
            content = content.replaceAll('src="_', "src=\"${prefix}/_")
            content = content.replaceAll('alt="_', "alt=\"${prefix}/_")
            content = content.replaceAll('internal" href="', "internal\" href=\"${prefix}/")
            content = content.replaceAll('"search.html"', "\"${prefix}/search.html\"")
            content = content.replaceAll('"genindex.html"', "\"${prefix}/genindex.html\"")
            writeFile(file: '404.html', text: content)
        }
    }

    stage('Archive generated folder') {
        archiveArtifacts artifacts: 'gh-pages/**/*.*'
    }

    stage('Publish to gh-pages') {
        dir('gh-pages') {
            sh 'git init .'
            sh 'git checkout -b gh-pages'
            sh 'git add .'
            sh 'git config user.email "conanci@jfrog.com"'
            sh 'git config user.name "ConanCI bot"'
            sh 'git commit -m "Automatic deploy"'
            //withCredentials([string(credentialsId: 'GITHUB_API_KEY', variable: 'GITHUB_API_KEY')]) {
            //    sh "git remote add origin-pages https://${GITHUB_API_KEY}@github.com/conan-io/docs.git"
            //}
            //sh 'git push --quiet --force --set-upstream origin-pages gh-pages'
        }
    }

    stage('Check') {
        sh 'ls -la'
        sh 'ls -la gh-pages'
        sh 'ls -la gh-pages/en'
        sh 'ls -la gh-pages/latest'
        sh 'cat gh-pages/404.html'
    }
}
